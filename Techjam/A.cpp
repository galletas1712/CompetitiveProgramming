/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author szawinis
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>
#define long long long
#define pii pair<long, long>
#define x first
#define y second
using namespace std;
const long MOD = 1e9+7, LINF = 1e18 + 1e16;
const int INF = 1e9+1;
const double EPS = 1e-10;
const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

class TJ_A {
private:
	int n, m;
	vector<pii> V;
	long cross(pii a, pii b, pii c) {
		return (c.y - a.y) * (b.x - a.x) - (b.y - a.y) * (c.x - a.x);
	}
public:
	void solve(istream& cin, ostream& cout) {
		auto cmp = [&](const pii &a, const pii &b) {
			return (a.y - V[0].y) * (b.x - V[0].x) <= (b.y - V[0].y) * (a.x - V[0].x);
		};
		cin >> n;
		for(int i = 0; i < n; ++i) {
			long a, b;
			cin >> a >> b;
			V.emplace_back(a, b);
		}
		for(int i = 1; i < n; ++i) if(V[i].y < V[0].y) swap(V[i], V[0]);
		sort(V.begin()+1, V.end(), cmp);
		cin >> m;
		while(m--) {
			long x, y; cin >> x >> y;
			if(y < V[0].y) {
				cout << "Outside" << endl;
				continue;
			}
			if(y == V[0].y) {
				if(pii(x, y) == V[0]) cout << "On the boundary" << endl;
				continue;
			}
			int l = 0, r = n-1;
			while(l < r) {
				int m = l + r + 1 >> 1;
				if(cmp(V[m], pii(x, y))) l = m;
				else r = m-1;
			}
			pii a = V[r], b = V[(r+1) % n], c = pii(x, y);
			long val = cross(a, b, c);
			if(val == 0) cout << "On the boundary" << endl;
			else if(val < 0) cout << "Outside" << endl;
			else cout << "Inside" << endl;
		}
	}
};

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	TJ_A solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
