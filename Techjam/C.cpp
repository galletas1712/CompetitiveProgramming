/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author szawinis
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>
using namespace std;
#define long long long
const long MOD = 1e9+7, LINF = 1e18 + 1e16;
const int INF = 1e9+1;
const double EPS = 1e-10;
const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
const int N = 1e3+5;


class TJ_C {
	int n, P;
	vector<int> g[N];
	vector<long> vec;
	int sz[N];
	void get_sz(int u, int p) {
		sz[u] = 1;
		if(p)g[u].erase(find(g[u].begin(), g[u].end(), p));
		for(int &v : g[u]) {
			get_sz(v, u), sz[u] += sz[v];
			if(sz[v] > sz[g[u][0]]) swap(v, g[u][0]);
		}
	}
	vector<long> dfs(int u, int p) {
		vector<long> dp;
		if(g[u].empty()) dp = vector<long>(vec.size(), 1);
		else dp = dfs(g[u][0], u);
		for(int i = 1; i + i < vec.size(); ++i) swap(dp[i], dp[vec.size()-i]);
		dp[0] = 0;
		for(int v : g[u]) if(v != g[u][0]) {
			vector<long> ret = dfs(v, u);
			for(int i = 1; i < vec.size(); i++) {
				dp[i] = (dp[i] * ret[((int)vec.size())-i]) % MOD;
			}
		}
		for(int i = 1; i < vec.size(); ++i) {
			dp[i] = (dp[i] * (vec[i] - vec[i-1]) + dp[i-1]) % MOD;
		}
		return dp;
	}
public:
	void solve(istream& cin, ostream& cout) {
		cin >> n >> P;
		for(int i = 1; i * i <= P; ++i) {
			vec.emplace_back(i), vec.emplace_back(P/i);
		}
		vec.emplace_back(0);
		sort(vec.begin(), vec.end());
		vec.resize(unique(vec.begin(), vec.end()) - vec.begin());
		for(int i = 1, u, v; i < n; i++) {
			cin >> u >> v;
			g[u].emplace_back(v), g[v].emplace_back(u);
		}
		get_sz(1, 0);
		cout << dfs(1, 0).back() << endl;
	}
};

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	TJ_C solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
