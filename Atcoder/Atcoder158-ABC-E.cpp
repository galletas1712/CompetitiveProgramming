/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <bits/stdc++.h>
using namespace std;

/* TYPES */
#define long int64_t
#define all(v) v.begin(), v.end()
#define fs first
#define sc second
typedef pair<int,int> pii;
typedef pair<int64_t,int> pli;
typedef pair<int64_t,int64_t> pll;
typedef vector<int> vi;
typedef vector<int64_t> vl;
typedef vector<pair<int, int> > vpi;
typedef vector<pair<int64_t, int64_t> > vpl;
typedef vector<string> vs;
typedef vector<vector<int> > vvi;
typedef vector<vector<int64_t> > vvl;

/* CONSTANTS */
const long P1 = 31, P2 = 37, MOD1 = 1e9+7, MOD2 = 1e9+9, LINF = 1e18 + 1e16;
const double EPS = 1e-10;
const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

/* FUNCTIONS */
template<typename T, typename U> inline void setMin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void setMax(T &x, U y) { if(x < y) x = y; }
template<typename T>
inline T gcd(T a, T b) {
    T c;
    while(b) c = b, b = a % b, a = c;
    return a;
}
template<typename T>
inline T square(T a) { return a*a; }
inline long modPow(long b, long e, long mod) {
    if (e == 0) return 1ll;
    if (e == 1) return b;
    return modPow(b * b % mod, e >> 1, mod) * modPow(b, e & 1, mod) % mod;
}

class TaskE {

    int N;
    long P;

    vl gen_hashes (string s) {
        vl h(s.length() + 1);
        for (size_t i = 0; i < s.length(); ++i) {
            h[i + 1] = (h[i] * 10 + (s[i] - '0')) % P;
        }
        return h;
    }

    vl process_hashes(vl h) {
        for (size_t i = 0; i < h.size(); ++i) {
            long divisor = modPow(modPow(10, i, P), P - 2, P);
            h[i] = h[i] * divisor % P;
        }
        return h;
    }

    long calculate_combinations(vl proc_h) {
        sort(all(proc_h));
        long value = -1, count = 0, ans = 0;
        for (long h : proc_h) {
            if (value == h) {
                ++count;
                continue;
            }
            if (value != -1) {
                ans += count * (count - 1) / 2;
            }
            value = h;
            count = 1;
        }
        ans += count * (count - 1) / 2;
        return ans;
    }

    long case_two(string s) {
        long ans = 0;
        for (size_t i = 0; i < s.length(); ++i) {
            if ((s[i] - '0') % 2 == 0) {
                ans += i + 1;
            }
        }
        return ans;
    }

    long case_five(string s) {
        long ans = 0;
        for (size_t i = 0; i < s.length(); ++i) {
            if (s[i] == '5' || s[i] == '0') {
                ans += i + 1;
            }
        }
        return ans;
    }

public:
    void solve(istream &cin, ostream &cout) {
        cin >> N >> P;
        string s;
        cin >> s;
        long ans;
        switch (P) {
            case 2:
                ans = case_two(s);
                break;
            case 5:
                ans = case_five(s);
                break;
            default:
                ans = calculate_combinations(process_hashes(gen_hashes(s)));
        }
        cout << ans << endl;
    }
};


class Solver {
public:
    void solve(std::istream& in, std::ostream& out) {
        TaskE *obj = new TaskE();
        obj->solve(in, out);
        delete obj;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    Solver solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
