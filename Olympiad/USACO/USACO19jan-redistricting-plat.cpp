/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

/*
 * Use prefix sum of +1, -1
 * dp[i] = min(dp[j] + (S[i] < S[j]))
 * So partition j into cases where S[i] < S[j] and S[i] >= S[j] using segment tree
 */
#include <bits/stdc++.h>
using namespace std;
#define long long long
const long MOD = 1e9+7, LINF = 1e18 + 1e16;
const int INF = 1e9+1;
const double EPS = 1e-10;
const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
const int N = 3e5+10, M = 2*N;

class redistricting {

	int n, k, S[N], dp[N];
	string s;
	multiset<int> ls[M];
	int t[2*M];

	void ins(int i, int v) {
		ls[i].insert(v);
		t[i + M] = *ls[i].begin();
		for(i += M; i > 1; i >>= 1)
			t[i >> 1] = min(t[i], t[i ^ 1]);
	}

	void del(int i, int v) {
		ls[i].erase(ls[i].find(v));
		t[i + M] = (ls[i].empty() ? INF : *ls[i].begin());
		for(i += M; i > 1; i >>= 1) {
			t[i >> 1] = min(t[i], t[i ^ 1]);
		}
	}

	int query(int l, int r) {
		int ret = INF;
		for(l += M, r += M+1; l < r; l >>= 1, r >>= 1) {
			if(l & 1) ret = min(t[l++], ret);
			if(r & 1) ret = min(t[--r], ret);
		}
		return ret;
	}

public:
	void solve(istream &cin, ostream &cout) {
		cin >> n >> k;
		cin >> s;
		for(int i = 0; i < n; i++) {
			S[i+1] = S[i] + (s[i] == 'H' ? 1 : -1);
		}
		for(int i = 0; i < 2*M; i++) t[i] = INF;
		ins(N, 0);
		for(int i = 1; i <= n; i++) {
			if(i >= k + 1) del(N + S[i - k - 1], dp[i - k - 1]);
			dp[i] = min(query(0, N + S[i] - 1), query(N + S[i], 2*N - 1) + 1);
			ins(N + S[i], dp[i]);
		}
		cout << dp[n];
	}
};

class Solver {
public:
	void solve(std::istream& in, std::ostream& out) {
	    redistricting *obj = new redistricting();
		obj->solve(in, out);
		delete obj;
	}
};

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	Solver solver;
	std::ifstream in("redistricting.in");
	std::ofstream out("redistricting.out");
	solver.solve(in, out);
	return 0;
}
